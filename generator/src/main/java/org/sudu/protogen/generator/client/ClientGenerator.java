package org.sudu.protogen.generator.client;

import com.squareup.javapoet.*;
import org.sudu.protogen.descriptors.Method;
import org.sudu.protogen.descriptors.Service;
import org.sudu.protogen.generator.DescriptorGenerator;
import org.sudu.protogen.generator.GenerationContext;
import org.sudu.protogen.generator.type.RepeatedType;
import org.sudu.protogen.generator.type.TypeModel;
import org.sudu.protogen.generator.type.UnfoldedType;
import org.sudu.protogen.generator.type.VoidType;

import javax.annotation.processing.Generated;
import javax.lang.model.element.Modifier;
import java.util.List;
import java.util.stream.Stream;

public class ClientGenerator implements DescriptorGenerator<Service, TypeSpec> {

    public static final String modificationNotice = """
            The client was generated by protogen. If you want to add some logic, mark the service using
            `option (protogen.abstract) = true;` and make your own class.
            """;

    static final ClassName channelClass = ClassName.get("io.grpc", "Channel");

    private final GenerationContext context;

    public ClientGenerator(GenerationContext context) {
        this.context = context;
    }

    @Override
    public TypeSpec generate(Service service) {
        FieldSpec stubField = FieldSpec.builder(service.blockingStubClass(), "blockingStub", Modifier.PRIVATE, Modifier.FINAL).build();
        TypeSpec.Builder builder = TypeSpec.classBuilder(service.generatedClientName())
                .addModifiers(Modifier.PUBLIC)
                .addField(stubField)
                .addAnnotation(AnnotationSpec.builder(ClassName.get(Generated.class)).addMember("value", CodeBlock.of("\"protogen\"")).build())
                .addMethods(generateConstructors(service))
                .addMethods(service.getMethods().stream()
                        .filter(Method::doGenerate)
                        .flatMap(m -> generateRpcMethod(stubField, m))
                        .toList()
                );
        if (service.isAbstract()) {
            builder.addModifiers(Modifier.ABSTRACT);
        } else {
            builder.addJavadoc(CodeBlock.of(modificationNotice));
        }
        return builder.build();
    }

    private List<MethodSpec> generateConstructors(Service service) {
        return List.of(
                MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(ParameterSpec.builder(channelClass, "channel").build())
                        .addCode(CodeBlock.of("this.blockingStub = $T.newBlockingStub($L);", service.stubClass(), "channel"))
                        .build(),
                MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(ParameterSpec.builder(service.blockingStubClass(), "stub").build())
                        .addCode(CodeBlock.of("this.blockingStub = stub;"))
                        .build()
        );
    }

    private Stream<MethodSpec> generateRpcMethod(FieldSpec stubField, Method method) {
        TypeModel returnType = getMethodReturnType(method);
        TypeModel requestType = context.typeManager().processType(method.getInputType());
        MethodSpec publicApi = new ApiMethodGeneratorBase(context, method, returnType, requestType).generate();
        MethodSpec grpcRequestMethod = new StubCallMethodGenerator(context, method, returnType, stubField).generate();
        return Stream.of(grpcRequestMethod, publicApi);
    }

    protected TypeModel getMethodReturnType(Method method) {
        var responseType = context.typeManager().processType(method.getOutputType());
        TypeModel type;
        if (responseType != null) {
            type = responseType;
        } else if (method.doUnfoldResponse(responseType)) {
            type = new UnfoldedType(context.typeManager().processType(method.unfoldedResponseField()), method.getOutputType());
        } else if (method.getOutputType().getFields().isEmpty()) {
            type = new VoidType();
        } else {
            throw new IllegalStateException(("Unable to create a method returning %s because request consist of more than " +
                    "1 field and doesn't have a domain object.").formatted(method.getOutputType().getFullName()));
        }
        if (method.isOutputStreaming()) {
            return new RepeatedType(type, method.getStreamToContainer());
        }
        return type;
    }

}
